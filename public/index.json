[{
    "id": "/docs/bash-scripting/",
    "title": "bash-scripting",
    "content": "Date: 2026-01-23 Intro A bash script is a file containing lines of code either simple commands or complex ones tha can either navigate directories or create other stuff; in simple words they can do a series of actions. Basically they can run bash commands eg ls , mkdir, ps, grep ,touch ,rm etc. A bash script can be executed and the lines of code inside it will be run line by line. Advantages of bash scripting Automation - Shell scripts allow a user to automate repetitive tasks hence saving on time and minimizing the risk of human error Portability - Can run on various OS including windows through VM\u0026rsquo;s HIghly flexible as they can be customized easily Easy to write as they require any special software Integration - Shell scripts can be integrated with other tools and applications and cloud services allowing for more complex automation and system management tasks Debugging - They are easy to debug and most of them have built-in debugging and error-reporting tools NOTE : Shell is a program responsible for displaying of an interface for interacting the OS(CLI- Command Line Interface). Bash is a type of shell. Creating and executing bash scripts Bash scripts end with .sh A bash script starts with a shebang. This is the first line which must be present in a script which specifies the interpreter that will be used when executing the script. This allows users to leverage the power of different interpreters. Shebang tells the shell to execute it via bash shell When saving a script file, its is good practice to place commonly used scripts in the ~/bin/ directory The script files also need to have the execute permission to allow them to run An example of a shebang statement (#!/bin/bash) The read command reads the input and stores it in the variable path The ls -al command takes the variable with the stored path and displays the details of the path We can then run the script using the following commands : sh hello.sh bash hello.sh - These commands(sh hello.sh) must be specified with the directory of the bash script if not in the bash script directory ./hello.sh - ./ tells the bash to execute hello.sh in the current working directory. We can use hello.sh to execute the bash script while on any directory of the terminal if the path of the script file is added to the $PATH variable . hello.sh When a script is executed using either the bash command or the dot (.) command, you do not have to set executable permissions on script but read permissions need to be set. Variables and data types Variables store data which can be read, accessed and manipulated eg : name=John We can also set a variable to a path of a particular directory as shown below path=/etc $ is required to access the variable\u0026rsquo;s content The naming conventions of a variable are : Variable names should start with a letter or an underscore (_). Variable names can contain letters, numbers, and underscores (_). Variable names are case-sensitive. Variable names should not contain spaces or special characters. Command line Arguments Command line arguments allow users to pass data to a bash script at runtime, These arguments are accessible inside the script using special variables.\nThe command line arguments are stored in special variables:\n$0 = The name of the script $1, $2, $3, \u0026hellip;\u0026hellip;. = First, second, third argument respectively etc $# - Total number of arguments passed to the bash script $@ - All the arguments supplied to the bash script $ $ - The process ID of the current script $USER - The username of the user running the script $HOSTNAME - The hostname of the machine the script is running on. Example showcasing command line arguments:\nQuotes We use quotes to enclose the values being assigned to a variable if we are working with complex values or values with spaces between. If we dont use quotes eg var=Hello World, there will be an error because by default, bash uses space for separate items.\nCommands work in the same way in the command line as they work in a script so we can just work in the command line for easier demonstration.\nWe enclose content in quotes so bash can consider it as a single item. We can use single quotes or double quotes\nSingle quotes will treat every character literally while double quotes may allow us to include other variables as part of the value as shown below :\nCommand Substitution This allows us to take the output of a command or program and save it as a value of a variable Exporting Variables When you run a shell script e.g. bash hello.sh, it starts a new process that is separate from the shell you are currently in. Its like opening a new mini terminal behind the scenes to run that script. Each process in Linux has its own memory - and variables live in memory - so a variable in your current shell won\u0026rsquo;t automatically be visible to that new process. \u0026ldquo;Variables are limited to the process they were created in\u0026rdquo;. Example script1.sh myname=\u0026ldquo;Chiman\u0026rdquo; bash script2.sh script2.sh echo \u0026ldquo;Hello $myname\u0026rdquo; When you run script1.sh, it starts a new process (script2.sh). But unless myname is exported, script2.sh will print nothing because it doesn\u0026rsquo;t know myname exists. To solve this problem we need to export the variable; export myname=\u0026ldquo;Chiman\u0026rdquo; bash script2.sh Input The read command takes user input and saves it into a variable. You can use the -p option which allows you to specify the kind of input the user should enter and also -s which makes the input silent, e.g. prompting a user their username and password\nread -p \u0026lsquo;Username: \u0026rsquo; uservar read -sp \u0026lsquo;Password: \u0026rsquo; passvar STDIN / STDOUT / STDERR (Will comeback to this when learning pipes)\nArithmetic Bash supports several ways to do arithmetic.\nlet expr Double parentheses (( )) Length of a variable ${#var} - useful for strings Let - A basic built-in command let a=5+4 # No spaces allowed unless in quotes echo $a # 9\nlet \u0026ldquo;a = 5 + 4\u0026rdquo; # You can use quotes to allow spaces echo $a # 9\nlet a++ # Increment a by 1 echo $a # 10\nlet \u0026ldquo;a = 4 * 5\u0026rdquo; # Multiplication echo $a # 20\nlet \u0026ldquo;a = $1 + 30\u0026rdquo; # Use a command-line argument\nOperator Meaning + Addition - Subtraction * Multiplication (use \\* in expr) / Division % Modulus (remainder) var++ Increment by 1 var-- Decrement by 1 expr - Print results and does not store expr item1 operator item2 expr 5 + 4 \u0026mdash;\u0026gt; Outputs: 9\nexpr \u0026ldquo;5 + 4\u0026rdquo; \u0026mdash;\u0026gt; Wrong: Just prints the string\nexpr 5+4 \u0026mdash;\u0026gt; Wrong: No spaces = no evaluation\nexpr 5 \\ * 4 \u0026mdash;\u0026gt; Right: Use \\ * to escape the multiplication symbol\nexpr 11 % 2 \u0026mdash;\u0026gt; Outputs: 1\na=$(expr 10 - 3) \u0026mdash;\u0026gt; Store result into variable a echo $a \u0026mdash;\u0026gt; 7\n(( )) - Recommended way to do arithmetic variable=$((expression))\n(( expression )) # For in-place operations like incrementing\na=$((4 + 5)) # 9 echo $a\na=$((3+5)) # 8 b=$((a + 3)) # 11 b=$(( $a + 4 )) # 12\n(( b++ )) # Increment b by 1 =\u0026gt; 13 (( b += 3 )) # b = b + 3 =\u0026gt; 16 a=$(( 4 * 5 )) # 20\n${#variable} – Get String Length a=\u0026ldquo;Hello World\u0026rdquo; echo ${#a} # 11\nb=4953 echo ${#b} # 4\nIf Statements If statements help the script to make decisions ; if [ ] then fi\n#!/bin/bash\nBasic if statementif [ $1 -gt 100 ] then echo Hey that's a large number. pwd fi date\n$1 is the first command-line argument.\n-gt means greater than.\nIf $1 is greater than 100:\nIt prints a message.\nShows current directory (pwd).\nfi marks the end of the if statement.\ndate runs no matter what.\n./if_example.sh 15 # Only date will be printed ./if_example.sh 150 # Message, directory, and date will be printed\nIn [ $1 -gt 100 ], the square brackets [ ] are a way to call the test command. Common test operators; ! EXPRESSION | Not true\n-n STRING | String is not empty\n-z STRING | String is empty\nSTRING1 = STRING2 | Strings are equal\nSTRING1 != STRING2 | Strings are not equal\nINT1 -eq INT2 | Equal numbers\nINT1 -gt INT2 | Greater than\n-e FILE | File exists\n-s FILE | File exists and is not empty\n-x FILE | File exists and is executable\nReferences https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners/ https://ryanstutorials.net/bash-scripting-tutorial/ ",
    "permalink": "/docs/bash-scripting/"
  },{
    "id": "/docs/disk-partitioning/",
    "title": "disk-partitioning",
    "content": "Date: 2026-01-23 Intro Understanding Mounting In simple terms, we know mounting as inserting eg a usb drive into your computer What really happens is that the system attaches a folder to the usb drive so that you can access its files. This happens to all other storage devices like a CD-ROM or a hard drive or even a floppy disk ( :) outdated) .The folder which the system attaches storage device is the mount point The main hard drive partition is mounted as \u0026ldquo;/\u0026rdquo; which is the root. CD-ROM - /media/cdrom USB drive - /mnt/usb NOTE - Suppose i wish to mount the CD-ROM which is located at /dev/sr0 to the mount point or folder /media/cdrom I need to be careful and understand that the files and subdirectories on CD-ROM will fall under /media/cdrom and any files that were originally at /media/cdrom will not be visible although they are present. When i unmount the CD-ROM the original files at /media/cdrom will become visible again. sudo mount /dev/sr0 /media/cdrom - command for mounting (This is crucial only for servers and crucial operations) Partitions A partition is like a section or part of a hard drive. Analogy, a house being the hard drive and rooms being partitions where each partition stores different stuff in it. In linux, hard drives are located in the /dev/ folder and are named as follows: /dev/sda - first drive /dev/sdb - second drive /dev/sdc - third drive Then partitions are labelled with numbers as follows: /dev/sda1 - first partion on the first drive /dev/sda2 - second partition on the first drive In the past, different types of hard drives had different names but this changed because of hotplug which is a new feature which unifies device management lsblk / sudo parted -l - command for listing all the drives and partitions df -h - command for viewing disk usage Every external storage has its block device location at /dev/ Use gparted app on ubuntu to see how your drive has been partitioned even for those who have dual-booted you will still see how the windows and linux have used the space MBR Partitions Traditionally, a hard drive is made up of many platters. On each platter there are 512 byte sectors making up a track. Many tracks stacked on top of each other make the cylinder. Data is stored on these 512 byte sectors. Nowadays , disks with 4k byte sectors are being manufactured for fast performance as compared to the old 512 bytes In the past, computers described hard drives using Cylinders, Heads, and Sectors (CHS). Modern systems use Logical Block Addressing (LBA), where every sector gets a number. For huge hard drives, an advanced version called LBA48 was introduced to handle more sectors. Master Boot Record (MBR ) is the older partitioning system that supports up to 4 primary partitions and a maximum disk size of 2 terabytes. GUID Partition Table (GUID) partitions GPT (GUID Partition Table) is the newer standard, supporting up to 128 partitions by default and larger disk sizes. GPT was designed for use with a UEFI-based system References ",
    "permalink": "/docs/disk-partitioning/"
  },{
    "id": "/docs/linux-boot-process/",
    "title": "linux-boot-process",
    "content": "Date: 2026-01-23 Intro When you turn on a computer or restart it, it must load an operating system. This process is called the boot process.\nBIOS In the past before transitioning into boot loaders, BIOS (Basic Input and Output Service), was being used. This was a code that was stored in a non-volatile memory such as ROM, EEPROM or flash memory. When a PC is turned on, this code is executed and performs a power on self test (POST) to check the machine. This code also determines the boot drive from the available removable/fixed storage and loads the first sector from the Master Boot Record (MBR) on that drive eg hard drive/ ssd or usb stick or DVD/CD\n1. BIOS/UEFI Initialization The computer\u0026rsquo;s firmware (BIOS or UEFI) performs a Power-On Self Test (POST) to check hardware (RAM, CPU etc) BIOS/UEFI locates the boot loader from the disk defined in the boot order 2. Bootloader (GRUB) Execution This is located in the MBR (Master Boot Record) for BIOS or EFI System Partition for UEFI. The common boot loader is GRUB A boot menu is then displayed if configured allowing the user to select different kernels or OS A Linux kernel is loaded into memory if selected The kernel parameters are passed from its configuration file 3. Linux kernel Initialization After the kernel which is a compressed image is loaded into memory, It extracts itself and initializes hardware drivers like CPU,memory Then the root filesystem is mounted from the partition specified by the bootloader The init process (PID 1) starts from the initial RAM disk 4. initrd or initramfs (Initial RAM Disk) Temporary filesystem is loaded into RAM Once the root filesystem is accessible, the real root is mounted and the temporary one is discarded References ",
    "permalink": "/docs/linux-boot-process/"
  },{
    "id": "/docs/linux-file-system/",
    "title": "linux-file-system",
    "content": "Date: 2026-01-23 Intro \u0026ldquo;You see, back then, Linux was not the intuitive, user-friendly system it is today. You had to read a lot. You had to know things about the frequency rate of your CRT monitor and the ins and outs of your noisy dial-up modem, among hundreds of other things. I soon realized I would need to spend some time getting a handle on how the directories were organized and what all their exotic names like /etc (not for miscellaneous files), /usr (not for user files), and _/_bin (not a trash can) meant.\u0026rdquo; ~ Paul Brown.\n/ - This is the root directory\n/bin This directory contains binaries - these are some of the applications and programs that can run There are still more bin directories /boot Contains files that are required for starting the system - do not mess with anything here /dev Contains device files - generated at boot time or when you plug in a usb stick ,it will pop up here /etc Gets the name from \u0026ldquo;et cetera\u0026rdquo; because at the earlier days of linux, system administrators would dump files they were not sure to put but nowadays its not the case, etc stands for \u0026ldquo;everything to configure\u0026rdquo; because it contains most of the system files configurations. Users in the system, their passwords, system name files, disk partition details. /home This contains the users\u0026rsquo; personal directories, my personal directory is home/astro. Will soon create another user home/guest for anyone that wants to use my system. /lib Contains libraries - these are files containing code that applications use to run There are other /lib directories but this one is special as it contains the kernel modules/drivers eg sound card, video card, wifi , bluetooth etc /media This is where the external storage is mounted when you plug it in your machine /mnt Not used very often but it was used days back when manually manually mounting storage devices /opt The directory where the software you build yourself will land. Applications will land in /opt/bin and libraries in the /opt/lib directory Applications and libraries may also end up in /usr/local/bin and /usr/local/lib directories, this will depend with the configurations of developers /proc This is a virtual directory like /dev. Contains information about your computer eg CPU info and the kernel your Linux system is running. The files and directories are generated when your sytem is booting or when certain files related to it are changing /root This is the home directory of the superuser. Dont confuse it with the root directory \u0026ldquo;/\u0026rdquo; /run This is where system processes use to store temporary data /sbin Similar to /bin but it contains the applications the superuser will need. Contains tools that install stuff, delete stuff and format stuff /usr Back in the days, this was where users\u0026rsquo; home directories were originally kept These days it contains directories of applications, libraries, documentation, wallpapers, icons and other stuff to be shared by applications and services Contains bin, sbin and lib directorries as well. Originally, the /bin directory (hanging off of root) would contain very basic commands, like ls, mv and rm; the kind of commands that would come pre-installed in all UNIX/Linux installations, the bare minimum to run and maintain a system. /usr/bin on the other hand would contain stuff the users would install and run to use the system as a work station, things like word processors, web browsers, and other apps. But many modern Linux distributions just put everything into /usr/bin and have /bin point to /usr/bin just in case erasing it completely would break something. /srv Contains data for servers eg a web server, HTML files would be stored at /srv/http (or /srv/www). If ruuning a FTP server, the files will be stored at /srv/ftp /sys This is another virtual directory like /proc and /dev, it also contains information from devices connected to the computer /tmp Contains temporary files from applications running in the system You can also use it to store your own temporary files /var Contains var/log subdirectories, logs are files that register events that happen on the system. If something fails in the kernel, it will be logged in a file in /var/log; if someone tries to break into your computer from outside, your firewall will also log the attempt here. It also contains spools for tasks.These “tasks” can be the jobs you send to a shared printer when you have to wait because another user is printing a long document, or mail that is waiting to be delivered to users on the system. References https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained ",
    "permalink": "/docs/linux-file-system/"
  },{
    "id": "/docs/networking-fundamentals/",
    "title": "networking-fundamentals",
    "content": "Date: 2026-01-23 Intro The OSI (Open Systems Interconnection) Model The osi model is a conceptual framework that describes seven distinct layers of network communication. It helps us to understand how different technologies work together to enable a network. Its basically a set of rules that explains how different computer systems communicate over a network. It consists of 7 layers and each layer has specific functions and responsibilities Layer 1 : Physical Layer The lowest layer of the OSI model Responsible for the actual physical connection between devices Contains information in the form of bits and transmits them from one node to the next (0s and 1s) When receiving data, this layer will get the signal received and convert it to 0s and 1s and send them to the DLL Common physical layer devices are hub, repeater and cables Physical layer specifies how the different devices are arranged in a network i.e. bus topology, star topology or mesh topology This layer also defines how the data flows between two connected devices e.g simples, half duplex and full duplex Layer 2 : Data Link Layer (DLL) Responsible for the node to node delivery of the message The main function is to make sure data transfer is error-free from one node to another over the physical layer When a packet arrives in a network, it is the responsiblity of the DLL to transmit it to the host using its MAC address. Switches and bridges are the common DLL devices Packet in the DLL is referred to as Frame DLL also encapsulates the sender\u0026rsquo;s and receiver\u0026rsquo;s MAC address in the header Layer 3 : Network Layer The network layer is responsible for the transmission of data from one host to the other located in different networks. It also takes care of packet routing i.e. selection of the shortest path to transmit the packet from the number of routes available The sender\u0026rsquo;s and receiver\u0026rsquo;s IP address are placed in the header by the network layer Network layer is implemented by networking devices such as routers and switches Protocols - IP(Internet Protocol), ICMP (Internet Control Message Protocol) Layer 4 : Transport Layer It is responsible for the end to end delivery of the complete message (reliability of communication) through flow-control and error control Data from session layer is divided into units called segments. Each segment has a port number and sequence number. Port number is used to direct each segment to the correct application/service Sequence number is used to arrange the segments into the correct order to form a correct message at the receiver. Transport layer helps in flow-control i.e it helps in controlling the amount of data being transmitted. Transport layer also helps in error-control i.e if some data fails to reach the destination, transport layer uses Automatic Repeat Request schemes to retransmit the lost or corrupted data. It also adds source and destination port number in its header Protocols - TCP (Transmission Control Protocol)(connection-oriented transmission), UDP (User Datagram Protocol)(connectionless transmission) Layer 5 : Session Layer This layer is responsible for the establishment of connections, management of connections, termination of sessions between 2 devices. It also provides authentication and security Layer 6 : Presentation Layer Also called the translation layer. The data from the application layer is extracted here and manipulated as per the required format to transmit over the network. After translation, data can be compressed so that it is transmitted effectively After compression, data is encrypted for security. Protocols used here are TLS/SSL for encryption. Layer 7 : Application Layer Provides the interface for applications to access network services. Protocols: HTTP, HTTPS, FTP, SMTP, DNS Analogy Step 1: Person A interacts with e-mail application like Gmail, outlook, etc. Writes his email to send. (This happens at Application Layer). Step 2: At Presentation Layer,Mail application prepares for data transmission like encrypting data and formatting it for transmission. Step 3: At Session Layer there is a connection established between the sender and receiver on the internet. Step 4: At Transport Layer, Email data is broken into smaller segments. It adds sequence number and error-checking information to maintain the reliability of the information. Step 5: At Network Layer, addressing of packets is done in order to find the best route for transfer. Step 6: At Data Link Layer, data packets are encapsulated into frames, then MAC address is added for local devices and then it checks for error using error detection. Step 7: At Physical Layer, Frames are transmitted in the form of electrical/ optical signals over a physical network medium like ethernet cable or WiFi. Ports These are communication endpoints that allow different services on a device to send and receive data. Each port is associated with a specific service or process.The use of ports helps computers understand what to do with the data they receive. Suppose Bob transfers an MP3 audio recording to Alice using the File Transfer Protocol (FTP). If Alice\u0026rsquo;s computer passed the MP3 file data to Alice\u0026rsquo;s email application, the email application would not know how to interpret it. But because Bob\u0026rsquo;s file transfer uses the port designated for FTP (port 21), Alice\u0026rsquo;s computer is able to receive and store the file.\nPort Number Service 20 File Transfer Protocol 21 File Transfer Protocol 22 Secure Shell (SSH) Secure login 23 Telnet Remote Login 25 Simple Mail Transfer Protocol (SMTP) 53 Domain Name System (DNS) Service 80 Hypertext Transfer Protocol (HTTP) 110 Post Office Protocol(POP3) 123 Network Time Protocol (NTP) 143 Internet Message Access Protocol(IMAP) 161 Simple Network Management Protocol(SNMP) 443 HTTP Secure(HTTPS) Subnetting This is the process of dividing a large network into smaller, more manageable subnetworks. Every IP address e.g 192.168.1.10 has 2 parts; Network ID Host ID The subnet mask is the line that separates them. An example : 192.168.1.10/24 The IP is 192.168.1.10 while the mask is /24 or 255.255.255.0 The mask /24 means that the first 24 bits (the first 3 numbers) belong to the network ID; 192.168.1. This means that only devices that have their IP addresses starting with 192.168.1 can talk directly with each other. The remaining .10 belong to the host ID. This is the host device. If a raspberry Pi is 192.168.1.50, it has the same network ID and it can communicate directly. On the other hand, if a server is 192.168.2.50, it has a different network ID and a router(Gateway) is needed for communication. CIDR notation = /24. /32(One device) - Only fits 1 IP /24(Standard LAN) - 256 IPs but we remove the first(Network ID) and last(broadcast) so it fits 254 devices. The broadcast is the speacial IP address used to send a packet to all of the devices in a particular network segment. /16(Huge Network) - fits 65,534 devices /0(The Internet) - 0.0.0.0/0 The larger the number after /, the smaller the network. Every time we increase the number by one, /25 we split the previous number of devices by half 256/2, so /25 wil fit 128 IPs. Switches and routers A switch connects devices that are on the same network. It creates a Local Network (LAN).For example, it lets my laptop communicate with the raspberry PI or my phone to the printer.\nIt does not care about IP addresses. It uses MAC addresses to identify devices on the LAN.\nIt operates on the data link layer.\nA Router connects different networks, a private home network to the public internet.\nIt uses IP addresses to operate. For example when browsing through the internet from a laptop.\nRouting This is the process of directing data packets from source to destination across a network. They use routing tables and protocols to decide the path for data transmission ensuring efficient and reliable communication between devices. How does routing work ? Data moves along any network in form of data packets. Each data packet has a header that contains information about the packet\u0026rsquo;s intended destination. As a packet travels to its destination, several routers might route it multiple times. Routers perform this process millions of times each second with other millions of packets.\nWhen a data packet arrives, the router first checks its address in the routing table, the router then forwards the packet on to the next point in the network.\ntypes of routing Static routing - A network administrator manually configures and selects network routes.\nDynamic routing - Routers create and update routing tables at runtime based on actual network conditions. They attempt to find the fastest path from the source to the destination by using a dynamic routing protocol, which is a set of rules that create, maintain and update the dynamic routing table. Its biggest advantage is that it adapts to changing network conditions e.g. traffic volume, bandwidth and network failure.\nReferences https://www.geeksforgeeks.org/computer-networks/open-systems-interconnection-model-osi/ https://www.cloudflare.com/en-in/learning/network-layer/what-is-a-computer-port/ ",
    "permalink": "/docs/networking-fundamentals/"
  },{
    "id": "/docs/openssh/",
    "title": "openssh",
    "content": "Date: 2026-01-23 Intro OpenSSH (Open Secure Shell) is a free, open-source toolset that allows for secure remote login and other secure network services over an insecure network i.e. the internet. It encrypts all traffic during a session and guarantees the integrity of data transfer\nsshd - The OpenSSH server daemon ssh - Short form for secure shell, provides a secure channel to the command shell on the remote system scp - secure copy, for encrypted file transfer sftp - secure file transfer protocol, provides file access ssh-copy-id - a program for installing your public key to a remote SSH server\u0026rsquo;s authorized_keys file ssh-keyscan - finds and collects public host keys on a network, saving time of looking for them manually ssh-add - adds your identities to the authentication agent, ssh-agent sshfs - Allows you to mount a remote filesystem using sftp ssh-agent - a program that securely manages and stores your SSH private keys in memory, making it easier to authenticate with remote servers without repeatedly entering passphrases. This allows you to authenticate with SSH servers once and then use that authentication for multiple connections without needing to re-enter your key\u0026rsquo;s passphrase OpenSSH supports different types of authentication;\nPassword authentication - Uses your LInux login and password to authenticate. Simplest but vulnerable when your SSH session is infected with a keylogger which can capture your credentials.\nPublic key authentication - This authenticates with your personal SSH public keys. You need to create and distribute your public keys and you can login only from machines that hold your private key\nPassphrase-less authentication - Public key authentication without a passphrase. Useful for automated services like scripts and cron jobs\nThere are two different uses for authentication keys: host keys, which authenticate computers, and public keys, which authenticate users. SSH keys come in pairs, private and public. Transmissions are encrypted with the public key and decrypted with the private key, a brilliantly simple scheme. You can safely distribute your public keys as much as you want, while you must protect your private key and not let anyone else have it.\nServer and client are defined by the direction of the transaction. The server has the SSH daemon running and listening for connection requests, and the client is anyone logging in to this machine via SSH.\nsudo ssh-keygen -A\nssh-keygen: generating new host keys: RSA DSA ECDSA ED25519\nserver’s private host keys are owned by root, read-only\npublic keys, which are owned by root, read-write for root, and read-only for everyone else\nNow take a look at /etc/ssh/sshd_config. When you change this file(Uncomment the options you want to use or change.), reload sshd to load your changes:\n$ sudo systemctl reload sshd.server Any port scanner will find your open ports, and attackers will attempt brute force password cracking. Attackers still target the default SSH port 22 the most. Changing the port won’t reduce this risk very much, but it should reduce the number of entries in your log files. When you use alternate port numbers, first look in /etc/services to find unused ports, and then record the ports you use in this file.\nPublic key authentication is very strong and cannot be brute-forced like password logins (see Recipe 12.7). The trade-off is less convenience, as you can log in only from machines that have your private key.\nReferences ",
    "permalink": "/docs/openssh/"
  },{
    "id": "/docs/shell-commands/",
    "title": "shell-commands",
    "content": "Date: 2026-01-23 Intro When you type a command in the terminal, your system looks for the executable file in the directories listed in the $PATH variable. If a directory isn\u0026rsquo;t in $PATH, you must specify the full path to run a script.\nUse any of the following options to get more information about linux commands:\nman commandName info commandName commandName -h commandName \u0026ndash;help env This command will show special variables ls This command is used when listing all the files that are inside a container. It has several combinations such as -al which returns more detailed information about the files inside a particular folder. lsblk This command will show the disks and their partitions info of your pc cat This command is used to show the contents of a file eg\ncat /etc/systemd/network.sh cd The change directory command makes it possible for you to move inside a specified path/folder. by using cd .. ,you move to the previous directory/parent folder. pwd This command is used to know which directory you are in, by running it ,it will print the current folder path mkdir This command is used to create folders YOu can create multiple folders with one command: mkdir dogs people You can also create multiple nested folders by adding the -p option: mkdir -p fruits/apples rmdir Used to delete a folder or multiple folders at once ( The folder must be empty) To delete folders with files in them (rm -rf fruits people) mv Used to move a file by specifying the file\u0026rsquo;s current path and its new path (mv pear new_pear) - Renaming files and folders If the last parameter is a folder, the file located at the first parameter is going to be moved into the folder (mv pear apple fruits) - pear and apple moved to the fruits folder cp Used to copy a file To copy folders, you need to add the -r to recursively copy the whole folder contents (cp -r fruits people) touch Used to create an empty file eg touch apple open Used to open a directory (open .) - opens the current directory Can also be used to open an application find The find command can be used to find files or folders matching a particular search pattern. It searches recursively (find . -name \u0026lsquo;*.js\u0026rsquo;) - Find all files under the current tree that have the .js extension and print the relative path of each file that matches (find . -type d name src) - Find directories under the current tree matching the name \u0026lsquo;src\u0026rsquo; (find folder 1 folder 2 -name filename.txt) - Searching under multiple root trees (find . -type d -name node_modules -or -name public) - Find directories under the current tree matching the name \u0026rsquo;node_modules\u0026rsquo; or \u0026lsquo;public\u0026rsquo; (find . -type d -name \u0026lsquo;.md\u0026rsquo; -not -path \u0026rsquo;node_modules/\u0026rsquo;) - excluding a path (find . -type f -size +100c) - Searching files that have more than 100 characters(bytes) in them (find . -type f -size +100k -size -1M) - Searching files bigger tha 100KB but smaller than 1MB (find . -type f -mtime +3) - Searching files edited more that 3 days ago (find . -type f -mtime -1) - Searching files edited in the last 24 hrs ln Used to create links(Pointer to another file) There are two types of links(hard links and soft links Hard links are rarely used. You cant link to directories and external filesystems (ln recipes.txt newrecipes.txt) - Creating a hard link Soft links are different. They are more powerful as you can link to other filesystems and to directories but when the original is removed, the link will be broken (ln -s recipes.txt newrecipes.txt) - Creating a soft link gzip Used for compressing a file (gzip filename) - This will compress the file and append the .gz extension to it and the original file is deleted. To prevent this, use the -c option and use the output redirection to write the output to the filename.gz file. ( gzip -c filename \u0026gt; filename.gz) (gzip -d filename.gz) - Decompressing the file gunzip Basically the equivalent of gzip only that when decompressing, no need for adding the -d tar Used to create an archive, grouping multiple files in a single file (tar -cf archive.tar file1 file2) - Creates an archive named archive.tar with the content of file1 file2 (tar -xf archive.tar) - Extract files from an archive in the current folder alias This is like creating a new command to mimic an existing command so that you dont use the existing command according to your preferences (alias ll = \u0026rsquo;ls -al\u0026rsquo;) - Creating a new command \u0026rsquo;ll\u0026rsquo; that is an alias to \u0026rsquo;ls -al\u0026rsquo; (alias) - will list all the aliases defined The alias will work until the terminal sessions is closed To make it permanent, add it to the shell configuration tail Opens the file at the end and watches for file changes Great for watching log files ( tail -f /var/log/system.log ) grep Used to search in lines or can be combined with pipes to filter the output of another command (grep \u0026ldquo;error\u0026rdquo; logfile.txt) - Finds and prints all lines in logfile.txt containing the word \u0026ldquo;error\u0026rdquo; (grep \u0026ldquo;hello\u0026rdquo; file1.txt file2.txt) - Searches for \u0026ldquo;hello\u0026rdquo; in both files You can use -i to ignore case sensitivity (grep -i \u0026ldquo;error\u0026rdquo; logfile.txt) - Finds \u0026ldquo;Error\u0026rdquo;, \u0026ldquo;error\u0026rdquo; ,etc Can also be used in searching in the output of another command as shown in the next line ps aux | grep \u0026ldquo;firefox\u0026rdquo; (grep -v \u0026ldquo;error\u0026rdquo; logfile.txt) - Inverting the search ie exclude all lines that contain the pattern (grep -n \u0026ldquo;command\u0026rdquo; logfile.txt) - Shows the line numbers where \u0026ldquo;command\u0026rdquo; has appeared (grep -c \u0026ldquo;error\u0026rdquo; logfile.txt) - counts the number of lines containing \u0026ldquo;error\u0026rdquo; (grep \u0026ldquo;^hello\u0026rdquo; file.txt) - search for lines that start with \u0026ldquo;hello\u0026rdquo; (grep \u0026ldquo;done$\u0026rdquo; file.txt) - search for files that end with \u0026ldquo;done\u0026rdquo; sort Used in sorting elements in a file (sort -r filename.txt) - Reverses the order of sorting Can work with pipes,i.e you can use it on the output of another command ls | sort echo echo \u0026ldquo;Hello world\u0026rdquo; - prints a simple messsage name=\u0026ldquo;John\u0026rdquo;, echo \u0026ldquo;Hello $name\u0026rdquo; - This will print the value of variable echo \u0026ldquo;Hello, file\u0026rdquo; \u0026gt; output.txt - This will direct the output to a file but will override the contents of that file echo \u0026ldquo;Hello file\u0026rdquo; \u0026raquo; output.txt - This will append or add another line at the end of output.txt echo \u0026ldquo;Today is $(date) - Using echo with other commands chown Every file/directory in linux has an owner This command is used to change the owner of the file or directory The owner of a directory/ file or the root user are eligible to use this command sudo chown astro test.txt - Transferring the file ownership to astro chown -R - Changing the ownership of a directory and all other files in it. chown : - Through this command,I can simulataneousy change the owner and the group of the file chgrp - Directly changing the group of the file chmod Used to change the permissions of a file Every file has 3 permissions (read, write and execute) For example if a go into a directory and run ls -al, the following is displayed :\ndrwxrwxr-x 4 astro astro 4096 Feb 9 11:33 .\ndrwxr-x\u0026mdash; 31 astro astro 4096 Feb 12 14:50 ..\ndrwxrwxr-x 8 astro astro 4096 Feb 13 12:32 .git\ndrwxrwxr-x 2 astro astro 4096 Feb 13 12:39 linux-basics\n-rw-rw-r\u0026ndash; 1 astro astro 163 Feb 9 11:32 README.md The letters and hyphens you see at the start of every file/folder are the permissions given of the file/folder (-) means its a normal file (d) means its a directory (l) means its a link After that, the first 3 values eg rwx represents the permissions of the owner of the file/directory The next 3 values eg r-x represents the permissions of the group of the file The last 3 values eg \u0026mdash; represents the permissions of the other members or everyone else that comes across the file rwx means that person has read, write and execute permissions of the file/directory If either of the rwx values is swapped with - ,that means that person lacks the swapped permission eg : r-x means the person has read and execute permission but lacks the write permission You can change the permissions using the chmod command Changing permissions using numeric notation discussed below :\nEach Permission has a numeric value :\nr = 4\nw = 2\nx = 1 chmod 755 file.txt - This command sets the owner : rwx (7), Group r-x (5) and others r-x (5) Changing the permissions using symbolic notation as shown below :\nu = Owner\ng = Group\no = Others chmod u+w file.txt - This adds the write permission to the Owner chmod g-x file.txt - This removes the execute permission from the group chmod o+r file.txt - This adds the read permission for others du This command will calculate the size of a directory as a whole du * - This will calculate the size of each file individually du -m - Displaying the size in Megabytes du -g - Displaying the size in Gigabytes du -ah - -a wil print the size of each file, -h will show a human readable notation for sizes df Used to get disk usage information Its basic form will print information about volumes mounted df -h will show the values in human readable format ps Used to inspect processes that are running on your machine ps ax - \u0026ldquo;a\u0026rdquo; will list other users\u0026rsquo; processes apart from yours and \u0026ldquo;x\u0026rdquo; will show other processes not linked to any terminal You can search for a specific process combining grep with a pipe as shown below :\nps ax | grep -i \u0026ldquo;tensorflow\u0026rdquo; | head pstree Command for displaying processes running on your system in a tree structure top Used to display dynamic real time information about running processes in your machine kill Linux processes can receive signals and react to them therefore we can interact with running programs The kill command is used to terminate a program (kill ). The PID is the process ID We can use the kill command to send other signals apart from terminating a program as follows :\nkill -HUP - hang up - It is sent automatically when a terminal window that started a process is closed before terminating the process\nkill -INT - interrupt - It sends the same signal used when we press ctrl - c in the terminal, which usually terminates the process\nkill -KILL - This is not sent to the process, but to the operating system which immediately stops but not terminate the process\nkill -TERM - terminate - Its the default signal sent by kill\nkill -CONT - continue - Used to resume a stopped process\nkill -STOP - stop is sent to the operating system kernel which immediately stops but does not terminate the process You might see numbers used instead, like kill -1 . In this case,1 corresponds to HUP. 2 corresponds to INT. 9 corresponds to KILL. 15 corresponds to TERM. 18 corresponds to CONT. 15 corresponds to STOP. type A command can be one of these 4 types :\nan executable\na shell built-in program\na shell function\nan alias The type command is used to figure out the type of a command type which This will return the path of the command specified man (manual) This command is used to display information about the specified command eg man which whoami This command will print the user name currently logged into the terminal session who This command displays the users logged in to the system su This command is used to switch to another user su sudo Used to run command as a root You must be enabled to use sudo and once you are authorised, you can run commands as root by entering your user\u0026rsquo;s password You can use sudo to run commands as any user. root is the default but use the -u option to specify another user :\nsudo -u astro ls /Users/flavio passwd Users in linux have a password assigned. You can change the password using the passwd command When you want to change your password, you can type :\npasswd When you are root , you can set the username for which you want to change the password :\npasswd ping This command pings a specific network host, on the local network or on the internet Syntax is ping where could be a domain name or an IP address This command sends a request to the server and the server returns a response ping keeps sending the request every second by default. It will keep running until you stop it with ctrl - c unless you pass the number of times you want to try with the -c option: ping -c google.com clear Used to clear all the previous commands that were run in the current terminal The screen will clear crontab Cron jobs are jobs that are scheduled to run at specific intervals. You might have a command perform something every hour, or every day, or every 2 weeks. Or on weekends. They are very powerful, especially when used on servers to perform maintenance and automations. crontab -l - exploring which cronjobs are defined by you uname This will return the Operating System codename eg Linux uname -mp - The m option shows the hardware name and the p option prints the processor architecture uname -a - This will print all the information available References https://www.freecodecamp.org/news/the-linux-commands-handbook/ ",
    "permalink": "/docs/shell-commands/"
  },{
    "id": "/docs/systemd/",
    "title": "systemd",
    "content": "Date: 2026-01-23 Intro Systemd is an init system in Linux-based operating systems that is responsible for starting the operating system and managing various services and processes. Think of it as the conductor for the system\u0026rsquo;s startup and ongoing operations, ensuring that everything runs smoothly. In older times, there was the System V initialization system (SysV init) which was popular for launching processes at startup. systemd attempts to decrease boot times and parcel out system resources more efficiently by starting processes concurrently and in parallel, and starting only necessary services, leaving other services to start after boot as needed. PID 1 - Mother of all Processes PID 1 is the mother of all processes on Linux systems. This is the first process to start then it launches all other processes. Processes are one or more running instances of a program.\nProcesses can create independent copies of themselves which are the child processes and the original the parent process. Each child has its own PID and its own allocation of system resources.\nThreads are lightweight processes that run in parallel and share system resources with their parents.\nSome processes run in the background and do not directly interact with the users, these are processes are ; services or daemons and their names tend to end with letter d such as httpd, sshd and systemd.\nps command to list all running processes in PID order\nThe pstree command organizes this mass of information into a tree diagram showing all processes, their child processes, PIDs, and threads, which are enclosed in curly braces.\nProcesses always exist in one of several states, and these states change according to system activity. • R is either currently running or waiting in the run queue. • l means the process is multithreaded. • S is interruptable sleep; the process is waiting for an event to complete. • s is a session leader. Sessions are related processes managed as a unit. • I is an idle kernel thread. • \u0026lt; means high priority. • N is low priority.\nsystemctl is used to list services and their states ; We are interested in service files because Linux users and administrators interact mainly with service files and rarely need to bother with any other type of unit file.\nTo check the service files, we use the command ;\nsystemctl list-unit-files \u0026ndash;type=service\nThe four most common states that a service can be in: enabled, disabled, static, or masked.\nList only enabled services: $ systemctl list-unit-files \u0026ndash;type=service \u0026ndash;state=enabled\nenabled - This shows that the service has become available and is managed by systemd.\nWhen a service is enabled, systemd creates a symlink in /etc/systemd/system/ from the unit file in /lib/systemd/system/. It can be started, stopped, reloaded, and disabled by the user with the systemctl command. Enabling a service does not immediately start it, and disabling a service does not immediately stop it.\ndisabled - Disabled means that there is no symlink in /etc/systemd/system/, and it will not start automatically at boot. You can stop and start it manually.\nmasked - This means the service is linked to /dev/null/. It is completely disabled and cannot be started by any means.\nstatic - This means that the unit file is a dependency of other unit files, and cannot be started or stopped by the user.\nsystemctl status bluetooth.service - used for querying the status of selected services\nStart a service: $ sudo systemctl start sshd.service\nStop a service: $ sudo systemctl stop sshd.service\nStop and then restart a service: $ sudo systemctl restart sshd.service\nReload the service’s configuration. For example, you made a change to sshd_config and want to load the new configuration without restarting the service: $ sudo systemctl reload sshd.service\nEnabling a service configures it to automatically start at boot.e.g sudo systemctl enable sshd.service\nStopping troublesome processes can also be done by killing them; $ sudo systemctl kill mariadb ,$ systemctl status mariadb ● mariadb.service - MariaDB 10.1.44 database server\nLoaded: loaded (/lib/systemd/system/mariadb.service; enabled; vendor preset: enabled) Active: inactive (dead) since Sun 2020-06-28 19:57:49 PDT; 6s ago\nThe service has cleanly stopped. If this does not work, then try the nuclear option: $ sudo systemctl kill -9 mariadb\ntop command is used to identify processes using up the most CPU resources\nReferences ",
    "permalink": "/docs/systemd/"
  }]
